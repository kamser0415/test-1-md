# Classicist Vs Mockist

Classicist
: 최대한 실제 객체로 테스트를 진행하다가 꼭 필요한 경우에만 
`Mocking`을 사용하자

Mockist
: 단위테스트를 다 완료한 상태에서 통합테스트를 할때 
이미 **테스트한 코드(단위 테스트)** 는 `Mocking` 처리로 테스트를 진행하자.
  
## 테스트 코드 방식
컨트롤러 계층은 외부에서 들어온 파라미터만 검증하는 역할이기 때문에
가벼운 테스트를 진행하기 위해서 나머지 의존성은 모킹 처리로 진행했습니다.  
그러다보니 컨트롤러 계층은 얇습니다.

그 다음 서비스 계층은 단위 테스트가 종료된 리포지토리 계층을 주입받아서 테스트를 진행하는
통합테스트로 진행을 했습니다.
이미 단위테스트를 통해서 검증된 리포지토리 오브젝트이지만 모킹처리를 하지 않고
구현체를 불러와서 테스트를 진행했습니다.

리포지토리 테스트는 `@SpringBootTest`를 사용하여 테스트를 진행했지만,
리포지토리 계층만 테스트를 진행하기 때문에 단위테스트 성격을 띕니다.
  
Mockist
: 서비스 테스트를 진행할 때 보장된 리포지토리를 모킹처리하여 테스트를 얇게하여 
시간과 비용을 아끼고 프로덕션 코드에 집중하는 것.  
  
## Mocking을 사용해야할 때   
`Mocking`을 사용하는 목적이 분명해야 합니다.  
외부 API와 통합하는 서비스가 있다고 한다면, 이 서비스의 특정 기능을 테스트 할 때 
외부 API의 응답을 실제로 기다리는 것은 시간과 비용이 발생합니다.  
  
그 대신 `Mocking`을 사용하여 외부 API의 응답을 모방하고, **실제 서비스**가 그 응답에 대해 
**어떻게 반응하는지 테스트**를 할 수 있습니다.  
  
이렇게 외부 API를 의존하지 않고 **_서비스의 특정 부분을 명확하게 테스트를 해야할 때_** 사용합니다.  
  
정리
: Mocking을 사용하는 이유는 외부 의존성을 제어하거나 모방하여 테스트를 하려는 특정 시나리오에 
집중하기 위해서입니다.  
  
## 주의사항
외부 시스템과 통합테스트 
: 외부 시스템과 통합이 중요한 경우 실제 외부 시스템과 통합된 테스트도 필요합니다. 
`Mocking`을 사용하지 않고 외부 시스템과 실제 통합을 확인하는 것을 의미합니다.  
  
Mocking 대상의 범위  
: 외부 API의 어느 부분을 Mocking 해야할지 명확한 기준을 정의해야 합니다. 
외부 시스템과의 통신뿐만 아니라 내부의 다른 컴포넌트들과의 상호작용도 포함될 수 있습니다. 
Mocking의 행위를 정확하게 지정하여 테스트 목적을 명확하게 해야합니다.  
다른 컴포넌트들이 그 행위에 대해 상호작용이 발생하는 상황이라면 명확한 범위와 예상 동작을 설정해야합니다.