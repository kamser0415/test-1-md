# Collection-Map

## Map이란
Map은 key-value를 한 쌍으로 1:1 매핑하여 관리합니다.
키는 Map 자료구조에 하나만 존재하며, value는 여러개가 존재할 수 있습니다.  
  
키는 중복되면 안되는 이유는 키를 hashCode로 변환하여 저장하기 때문입니다.  
네모난 박스 수십개가 정렬된 상태로 있으면 거기에 박스에 키를 해쉬로 변환하여 저장합니다.  
그렇기 때문에 키가 중복이 되면 데이터를 올바르게 찾아올 수 없으며 
만약 해쉬 충돌이 발생하여 키가 중복이 된다면 `equals()`를 통해 같은 객체인지 논리적으로 비교합니다.  
 
## HashTable 과 차이
+ HashTable은 컬렉션 프레임워크가 나오기 전에 추가된 기능이고 멀티쓰레드 환경에 맞춰 개발되었습니다.  
그러다보니 `Synchronized` 영향으로 속도 저하가 발생합니다.  
+ Map과 다르게 value에 null이 들어올 수 없습니다.(코드에서 체크합니다)
+ Map을 상속하여 키,값, 키-값을 호출 할 수 있지만 기본적으로 가지고 있는 메서드로는 삭제할 수 없습니다.   
+ `Enumeration`로 관리하지만 `Enumeration`을 자체로 넣어서 삭제하거나 할 수 없습니다.
    
## 사용하는 이유
**add가 아니라 put인 이유**  
순차적으로 데이터를 넣는 Collection과 다르게 Map는 key를 통해 지정된 index에 데이터를 넣기 때문에 
add가 아니라 put이 맞습니다.
**put의 반환이 null인 이유**  
get을 통해 인덱스가 잘못된 경우 해당 배열은 우리의 메모리 영역이아니라고 경고를 줘야하지만 
put에 사용하지 않은 키를 넣으면 null을 반환하는건 해당 키의 해쉬 영역부분에 데이터가 매핑되어있지 않기 때문에 
예외보다는 null이 맞을 수 있습니다.

## SortedMap을 상속한 TreeMap  
TreeMap을 왜 사용할까 생각했습니다.  
key를 기준으로 정렬이 되어있기 때문에 key가 중요한 구분값이라면 데이터를 빠르게 조회하고 
Navigator인터페이스를 상속하여 해당 키를 기준으로 이동도 가능합니다.  
  
물론 LinkedList도 이터레이터를 통해 좌우로 이동이 가능하고 정렬도 가능하지만 특정 키를 가지고 좌우로 이동할 수 있는 장점은 TreeMap이 가지고 있습니다.  

**NavigatorSet과 Map은 있는데 List는 없는 이유**  
NaviagtorSet과 Map은 존재하지만 NavigatorList 인터페이스가 없는 이유는 목적의 차이와 구조때문입니다.  
중복이 없이 해당 키를 기준으로 이동해야하는데 List는 중복이 가능하기 때문입니다.  
  
## Map이 Collection을 상속하지 않는 이유  
Collection은 순차적으로 데이터를 넣는 구조라면 Map은 순차적으로 데이터를 넣는구조가 아니기 때문입니다. 
키의 해쉬값에 따라 저장되는 위치가 달라지기 때문에 순서가 보장되지 않고, 특정 원하는 위치에 데이터를 넣을 수도 없습니다.  

## HashTable 사용하는 Properties 클래스  
Properties는 환경 변수나 애플리케이션 변수를 저장할 때 유용한 클래스입니다.  
Map과 HashTable을 사용하여 동시성과 설정값에 null체크를 하기 때문에 유용합니다
  
그리고 파일을 저장하고 주석처리를 도와주는 편의 메소드를 제공합니다. 
