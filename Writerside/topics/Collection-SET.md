# Collection-SET

## 필요한 이유    
`Set`을 사용하는 이유는 데이터의 중복을 제거하고 데이터 존재 유무를 빠르게 확인할 수 있는 컬렉션입니다.  
`List` 인터페이스나 `Set` 인터페이스나 모두 `Collection`을 상속하여 `contains` 매소드를 구현해야합니다.  
  
`Set`이 가진 장점중에서 데이터 존재유무를 확인할때 `List`보다 빠릅니다.  
`Set`의 대표 구현체인 `HashSet`의 `contains`와 `ArrayList`의 `contains`를 비교하면  
  
`List`는 equals를 통해서 동등성을 비교합니다.  
```Java
for (int i = start; i < end; i++) {
    if (o.equals(es[i])) {
        return i;
    }
}
```  
  
`Set`은 해시코드를 통해서 동등성을 비교합니다. 
```Java
if ((hash = hash(key) != null) {
    if (first.hash == hash .. 기타 로직)
        return first;
```   
  
> 모든 객체의 필드를 비교하는 `equals`보다 int 자료형으로 비교하는 `hashCode`가 더 빠를 수 밖에 없습니다.  
>   
  
데이터를 저장할 때 기존에 저장된 요소가 있는지 확인하고 데이터를 저장합니다.  

### Set의 목적
+ 데이터 중복없이 데이터를 관리
+ 데이터 존재 유무 확인  
  
## 주요 구현 클래스  
+ HashSet : 순서 x 가장 빠른 속도
+ TreeSet : red-black 트리 타입으로 입력된 기준으로 정렬됨, 성능 중간
+ LinkedHashSet : 저장된 순서에 따라 값이 정렬된다, 성능이 제일 구림  
  
### red-black 트리  
+ 시간 복잡도 O(logN)으로 데이터 조회,삭제,추가 가능  
+ 자가 균형 이진 트리로 숫자나 비교 가능한 값을 정리하는데 사용한다.  
+ [위키백과](https://w.wiki/9jkm)  
  
## HashSet  
+ hashCode와 equals로 데이터 중복 관리
+ `List` 인터페이스가 없으므로 인덱스 접근이나 조회가 불가능  
  
List는 생성자가 3개로 구성되어 있다.  
1. 기본 생성자
2. 컬렉션 생성자
3. 저장 용량 생성자  
  
Set은 추가 생성자로 `로드 팩터` 인자를 받는다.  
  
### 로드 팩터  
로드 팩터 = `데이터 개수` / `저장 공간 크기`  
  
List는 데이터가 추가될때 용량과 데이터 갯수가 똑같으면 2배씩 배열의 크기를 늘린다면  
Set은 데이터가 추가되어 로드 팩터보다 커진다면 내부 자료 구조를 다시 생성(`resize`)한다.  
  
로드 팩터는 밀도라고 생각하면 편한데, 저장 공간에 밀도가 높을 수록 데이터를 효율적으로 저장할 수 있지만 
그만큼 데이터를 찾기위한 시간도 증가합니다.  
  
밀도가 낮을 수록 데이터 검색 속도는 빠르지만 데이터 저장 공간이 작기 때문에 `resize`가 자주 발생할 수 있으므로 
기본 데이터 저장공간을 확보하는 것도 중요합니다.  
  
해시테이블에 객체를 저장할때 키와 값으로 저장합니다. 키는 해시값으로 변환하여 인덱스로 저장되는데 
이때 인덱스를 해시 버킷이라고 합니다.  
저장 공간이 동일하다면 밀도가 높은 것과 낮은 것은 차이가 있습니다.  
밀도가 높을 수록 데이터를 촘촘하게 넣어야하고 해시 충돌이 발생될 경우 같은 버킷에 데이터를 저장할 수 있습니다.  
그러면 해시 충돌이 발생해서 `equals`를 통해 한번 더 재확인을 하는 과정이 생길 수 있으므로 속도 저하가 발생한다는게 이유입니다.  
  
