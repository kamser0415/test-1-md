# Java-Thread
  
## 쓰레드란  
프로세스 내에 실행되는 작은 실행 단위입니다.  

### 멀티 쓰레드를 사용하는 이유
[멀티 프로세스와 멀티쓰레드](MultiThread.md)  
     
간단하게 정리하면, 멀티쓰레드를 사용하는 이유는 멀티 프로세스보다 제한된 자원을 효율적으로 사용할 수 있기 때문입니다.  
  
### 생성자 종류가 2개인 이유  
?

### 특징  
프로세스는 하나의 쓰레드를 꼭 갖습니다. 메인 쓰레드라고 하며 메인 쓰레드가 필요한 만큼의 멀티 쓰레드를 만들어 
실행합니다.  
이때 생성한 멀티쓰레드가 모두 종료되기전까지 메인 쓰레드는 종료되지 않습니다.  
  
### 속성  
쓰레드 마다 고유 속성값으로 사용하고 싶은 속성이나 이름을 파라미터로 받을 수 있습니다. 
Thread를 상속해서 생성자를 통해 필요한 인수를 내부 속성으로 저장하는 방식을 사용합니다.  
  
## 메서드 
쓰레드의 메서드를 사용할 때 정적 메소드인지, 인스턴스 메소드인지 확인할 필요가 있습니다.  
인스턴스 메소드는 해당 쓰레드에게 메세지를 전달하여 특정 기능을 수행하는 방식이라면, 
정적 메소드는 실행중인 현재 쓰레드에 대해서 정보나 명령을 실행할 수 있습니다.  
  
정적 메소드는 다시 생각해보면 인스턴스 쓰레드의 상태나 명령을 하기 위한 목적이 아닙니다. 
객체를 생성하지 않고 사용할 수 있기 때문에 JVM에서 실행중인 쓰레드를 관리하는 목적으로 사용됩니다.

### static  
+ sleep : 현재 실행중인 쓰레드의 상태를 `TIME_WAIT`로 변경합니다.
  + 항상 try-catch로 `interruptedException`을 통해 잡아줘야합니다.
  + 다른 쓰레드로부터의 인터럽트나 다른 예외 상황에 대비하여 안정성을 높이기 위한 것입니다.

### priority  
쓰레드에는 우선순위가 있습니다. 우선순위라는 말은 대기하고 있는 상황에서 더 먼저 수행할 수 있는 순위를 말합니다.  
  
### 데몬 쓰레드
쓰레드는 기본적으로 모두 종료가 되어야 메인 쓰레드가 종료됩니다.  
하지만 데몬 쓰레드는 호출한 쓰레드가 종료가되면 현재 어떤 상황이 되어도 같이 종료가 됩니다.  
  
## 동기화  
멀티쓰레드는 멀티프로세스와 다르게 자원을 공유하는 이점으로 인해 동시성 문제가 발생합니다.  
공유 데이터에 대해 갱실 손실이나 생각한 결과가 나오지 않을 수 있기 때문입니다.  
  
자바는 기본적으로 모니터락을 활용하여 동시성 문제를 해결할 수 있습니다.  

### synchronized  
자바에서는 모든 객체는 모니터 락을 가지고 있습니다.  
예약어를 통해 객체를 지정하면 객체의 모니터 락을 활용하여 동시성 문제를 해결합니다.  

![image_189.png](image_189.png)  
  
객체가 가진 한개의 모니터락을 여러 쓰레드가 경쟁하여 하나의 쓰레드가 획득하여 특정 `cretical section`을 사용할 수있습니다.  
```Java
// method 단위
synchronized methodA(){}

// 특정 영역 단위 (임계구역)
void methodA() {
    synchronized(this){
        //    
    }
}
```  
여기서 주의할 점이 있습니다. 임계구역은 해당 객체의 모니터락을 획득한 쓰레드만 접근이 가능하다고 했는데  
만약 클래스내에 `synchronized` 예약어가 여러개라면 나머지 메소드들도 접근할 수 없이 같이 잠깁니다.  
  
이런 메소드당 별개로 잠금을 사용하고 싶다면 lock으로 사용할 모니터 객체를 만들어서 개별로 사용하면 됩니다.  

```Java
class Example {
    private Object lock = new Object();
    
    void methodA(){
        synchronized(this){
        
        }
    }
    void methodB(){
        synchronized(lock){
        
        }
    }
}
```  
인스턴스 객체는 힙 메모리에 공유되는 자원이지만, 지역변수나 매개변수는 생명주기가 메소드 블럭 내에서만 유효하기때문에 
동시성 문제는 발생되지 않습니다. 메소드는 쓰레드 내에 스택에서 관리되기 때문에 다른 쓰레드가 접근할 수 없습니다.  
  
  
해당 그림을 다시보면 주의해야하는 점이 있습니다.  
+ Lock을 얻고 반납한 wait
+ Lock을 얻기위해 대기중인 entry  
  
모두 모니터 객체에 접근하여 락을 얻기위해 대기중이거나 락을 얻고 반납하고 대기중인 쓰레드들이 있습니다.  
  
여기서 `notify`,`notifyAll`은 락을 얻기 위해 대기중인 쓰레드를 깨우는게 아니라 
락을 얻고 스스로 반납한 쓰레드들을 깨우는 역할을 합니다.  
여기서 `notify`로 하나만 쓰레드를 깨울때는 순서가 정해져잇지 않습니다.  
  
## interrupt  
threadA.interrupt()로 호출하며 해당 쓰레드는 중단됩니다.  
그냥 중지시키는게 아니라 예외가 발생하면서 중지시킵니다.  
  
### 예외를 발생시키는 이유  
예외를 발생시키면서 중지시키는 것은 쓰레드가 중단될 때 정확한 처리가 이루어질 수 있도록 하는 
일종의 프로토콜입니다. 이를 통해 쓰레드가 안전하게 종료되고, 
메모리 누수나 다른 예상치 못한 문제가 발생하지 않도록 할 수 있습니다.   
  
```Java
try {
  //
} catch (..) {
  // 예외가 발생할 경우 쓰레드 종료로 처리를 명시할 수 있습니다.  
} 
```  
  
예외를 발생키시는 이유는 예외 처리를 명시적으로 할수 있습니다.  
  
[모니터 락 정리]((https://tarunjain07.medium.com/java-monitor-notes-40ff746dfec3))