# equalsAndHashCode

## 동등성과 동일성  
자바에서 동일성(identity)와 동등성(equality)는 다른 개념입니다.  
+ 동일성은 두 참조 변수가 같은 메모리 주소를 가리킬 때 동일하다고 말합니다
  + `==`을 사용하여 동일성을 비교합니다.
  + 물리적인 주소값을 비교합니다.
+ 동등성은 두 객체가 **논리적**으로 같은지 비교합니다. 
  + **논리적으로 같다.** 는 말은 객체는 객체가 가진 속성의 값이 같은 경우를 말합니다.
  + 자바에서는 객체를 논리적으로 같다고 표현하기 위해 `equals`를 재정의 합니다.  
  
정리하면, 동일성은 객체의 메모리 주소를 기반으로 한 비교이고, 
동등성은 객체의 내용을 기반으로 한 비교입니다. 특히 컬렉션 프레임 워크 내에서 
객체의 동등성을 비교하여 관리할 때 사용하므로 필수적입니다.  
  
## 고유 식별자  
자바는 개발자가 직접 메모리에 접근하여 관리하지 않도록 단순화하여 사용하도록 합니다.  
참조 변수를 사용하여 객체에 접근하고 관리 할 수 있도록 합니다.  
`hashCode`는 실제 메모리 주소 값이 아니라 객체의 내용에서 파생된 고유한 정수 값을 제공합니다.  
목적은 해시 테이블과 같은 자료 구조에서 객체를 효율적으로 관리하는 데 사용하기 때문이죠  
객체가 같은 값을 가지고 있다면 일관되게 동일한 값을 반환해야 하며, 다른 객체와 구별하기 위한 고유 식별자입니다.  
  
### hashCode만 구현?  
`hashCode`는 객체가 가진 데이터를 어떤 알고리즘에 적용하여 계산된 값입니다.  
해쉬 코드를 사용하는 이유는 객체를 비교할 때 드는 비용을 낮추기 위해서입니다.  
객체가 여러 필드가 있을때 `equals`로 비교하는 것보다 `int`값으로 비교하는게 더 저렴하기 때문이죠  
  
그렇지만 `hashCode`만 가지고 비교하지 않습니다.  
  
해시 충돌(`Hash Collisions`)이 발생하기 때문입니다.  
해시 충돌이 발생하는 원인은 `hashCode`로 표현할 수 있는 값이 int형으로 `21`억가지 입니다.  
하지만 CPU와 OS는 64bit를 사용하여 long형으로 표현할 수 있는 가지수의 차이가 발생합니다.  
다른 객체라고 할 지라도 해쉬 코드 값이 겹칠 수 있는 케이스가 발생합니다.  
  
자바는 호환성을 위해서 `int`자료형을 유지하기 때문에 이 문제를 해결하기 위해서 `equals`를 사용합니다.  
```Java
# HashMap put 메서드 일부 
if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
```  
  
따라서 자바에서는 hashCode와 equals의 결과는 동일해야합니다.