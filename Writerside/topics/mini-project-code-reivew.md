# mini-project-code-reivew

## 제어할 수 없는 값은 인터페이스로 분리  
`Random(),LocalDateTime()`처럼 매번 실행할 때마다 변경되는 값, 그리고 외부 API(`CRM API,CMS API,Email`)를 사용하여 
결과를 제어할 수 없는 경우가 있습니다.  
  
이럴때 결과에 대해서 다른 비즈니스 로직이 있는 경우 테스트 하기 어렵습니다.  
  
```Java
class MemberService {

    private OutSideApi outSideApi = new OutSideApi();
    
    public void buyItem(){
        long result = outSideApi.send(xxx);
        switch(result) {
            case 200 -> ooo;
            case 300 -> aaa;
            case 400 -> bbb;
            default -> throw new Exception();
        }
    }
}
```   
외부 API의 결과의 모든 경우의 수를 가지고 코드를 작성했습니다. 그러면 저 `buyItem`을 테스트 하려면 
매번 외부 API에 통신을 해야하고 `case`에 따라 결과 테스트를 하기 어렵습니다.  
  
이렇게 내가 코드를 수정하여 제어할 수 없는 경우 인터페이스로 분리를 해서 외부에 주입받도록합니다.  
  
```Java
class MemberService {

    private OutSideApi outSideApi;
    
    public MemberService(OutSideApi outSideApi){
        this.outSideApi = outSideApi;
    } 
    
    public void buyItem(){
        long result = outSideApi.send(xxx);
        switch(result) {
            case 200 -> ooo;
            case 300 -> aaa;
            case 400 -> bbb;
            default -> throw new Exception();
        }
    }
}
```
  
## 간단하게 코드리뷰 정리하기  

## 트랜잭션의 분리
1. `@Transactional`은 이미 만들어진 커넥션 풀에서 가져와 사용한다.  
  
커넥션 풀에 저장된 커넥션 객체의 숫자는 정해져 있고, 멀티 쓰레드 환경에서 필요한 경우 가져다 사용한다. 
이때 필요한 커넥션의 갯수가 전체 커넥션의 수보다 많아지면 서버가 죽을 수 있다.  
  
그러면 이때 빠르게 반납을 해서 대기중인 쓰레드를 줄여야하는데 
외부 API처럼 언제 응답이 떨어질지 모르는 상황, 혹은 같이 트랜잭션으로 묶여서 롤백처리가 된다고 할때 외부 API로 전송된 내용은 롤백처리가 안된다.  
  
그래서 외부 API를 사용하는 경우에는 같은 트랜잭션으로 묶을 필요가 없다.  

1. 외부 API가 오류가 발생한 결과가 현재 서비스 로직에 영향을 미치는 경우
2. 외부 API 로직은 정상 처리되었지만, 현재 서비스 로직이 오류가 발생해서 외부 API 로직을 롤백해야하는 경우  
  
이런 경우에는 어떻게 처리를 하면 좋을까?  
예를 들어:  
**우리의 서비스(A은행)**  
1. A은행 계좌의 잔금이 있는지 여부 확인 -> 없을 시, Exception 발생
2. B은행 계좌 전송
3. 전송 로직 수행
4. request 성공시, OK 코드 응답

**B은행**  
1. 송금이 들어오면 받는다.
2. OK 응답  
  
상황: 우리 서비스가 3번까지 성공하고, 3번과 4번을 수행하다가 500 에러가 발생하였으니 RollBack을 해야하는 상황이 되었고,
A은행 손님은 돈이 빠졌다가 롤백으로 다시 들어오게 되었고, B은행 손님은 돈이 들어온 상황이 되었습니다.  
  
이런 경우에는,  
#### 트랜잭션 분리  
**트랜잭션 시작**    
1. A 은행 계좌의 잔금이 있는지 여부 확인 -> 없을 경우 Ex 발생
2. A 계좌에서 돈을 출금
3. A 계좌에서 돈을 출금했다는 history 로그를 처리( 2번 구현에 따라 생략 가능 )  
  
**트랜잭션 종료**  
  
만약 이 안에 무언가 실패했다면 자연스럽게 후속 로직을 처리하지 않고, 정합성을 지킬 수 있음  
  
트랜잭션이 잘 성공하면, 다음 이어서 B 은행에 송금하는 로직 처리  
+ B 은행 송금 API가 성공하면, 전체 기능이 성공
+ B 은행 송금 API가 실패하면 3번에 만들어둔 history를 이용한 재시도를 하거나, 3번을 이용해 2~3번 과정을 수동 rollback 처리
+ A 계좌에서 롤백되었다는 history를 남김  
+ 전체 기능 실패  
  
#### 핵심
1. 꼭 모든 로직이 트랜잭션 안으로 들어갈 필요가 없다.
2. 트랜잭션 안으로 넣을 로직과 넣지 않아야 하는 로직을 구분해야 한다.  
  
#### 키워드
**보상 트랜잭션**  
  
## 도메인 객체를 DTO로 변환하는 로직 위치  
1. 도메인 클래스에 작성하는 방법:  
    ```Java
    class Member {
        //.. 생략
        public static Member toEntity(Dto Dto) { ... }
    } 
    ```
2. Dto 클래스에 작성하는 방법:  
    ```Java
    class MemberDto {
        //.. 생략
        public MemberEntity toEntity() { ...}
    } 
    ```
3. Mapper 클래스를 만들어 작성하는 방법:  
    ```Java
    class MemberMapper {
        public static MemberEntity toEntity(MemberDto dto) { ... }
    } 
    ```
   
### 답변  
1. 1번의 경우 멀티 모듈을 사용할 경우 엔티티가 DTO 클래스를 알 수 가 없다.  
    물리적으로 도메인이 DTO에 의존할 수 없기 때문에 불가능한 방법이고 확장성이 떨어진다. 도메인이 view에 가까운 DTO를 의존하는건 역설적이다.  
2. 3번의 경우에는 굳이 별로도 Mapper 클래스를 만들어서 관리할 이유가 없다.  
3. 2번을 선호하는 이유는 서비스 계층에서 두 객체를 변환하고 있을 수 없으니 DTO가 Entity로 변환하는 것이 낫다.  
    물론 1:1로 매핑 되는 경우에는 dto에 정적팩토리 메서드를 만들고 그 매개변수로 Entity를 갖게끔 할 수 있다. 1:N으로 매핑되거나 여러 조합이 필요한 경우에는 **일급 컬렉션** , 여러 객체를 모아주는 또 다른 객체등 다른 방식을 사용한다.  
  
### 키워드
**일급 컬렉션**  
  
  
## 타 엔티티를 제어해야할 때   
AEntity,BEntity를 관리하는 리포지토리, 서비스가 각각 있다고 할 때 
AService에서 BEntity를 저장,조회를 해야할 때 BService를 의존해야할까, BRepository를 의존해야할까?  
  
### 답변  
BRepository를 의존하는 것을 권장합니다.   
이유는 AService -> BService 로 의존의 된 상태에서 BService도 AService를 의존해야하는 상황이 발생하면 순환 참조가 발생합니다.  
다만, AService가 너무 많은 Repository를 의존하는 경우에는
1. 중간 계층의 서비스를 만든다.
2. API 자체를 분리한다.
3. 그외 방법
  
간단한 경우에는 계층의 역할을 벗어나지 않는 선에서 한 Service가 여러 Repository를 호출해도 된다.  
  
## 로직이 도메인으로 가야하는지 서비스로 가야하는지  
어떤 로직이 서비스 계층에 있어야 할지, 도메인 객체에 넣어야할지 고민이 될 때,  
### 답변  
가능한 도메인 단에는 로직을 작성하려고 노력하되, 외부 의존성이 발생하는 경우 (예: 암호화, 타 API 사용)이 **반드시 필요한 경우** 에는 서비스 단에 작성한다.  
정리하면, 유저 비빌번호가 간단하여 단순한 계산과 할당이면 도메인 쪽, 무거운 외부 암호화가 필요하다면 서비스 단에서 처리  
  
## API 중복 호출에 대한 처리 방법
1. 낙관적 락
2. 비관적 락
3. 유저 락
4. 유니크 키
  
## 도메인에 서비스 로직을 넣는 이유  
서비스에 모든 비즈니스 로직이 있는 경우 테스트를 할 때 해당 비즈니스 로직을 테스트하기 위해서 
필요하지 않은 서비스 객체의 의존성을 주입해야한다.  
  
도메인에 넣으면 해당 도메인만 별도로 테스트를 작성하면 되기 때문에 간편하게 테스트 코드를 작성할 수 있다.  
그리고 도메인과 도메인 끼리의 연산이라면 도메인 서비스 객체를 만들어서 별도의 일급 컬렉션을 만들어서 처리를 하는 방법도 있다. 

![image_122.png](image_122.png)

![image_123.png](image_123.png)  
  
추가로 테이블이 무조건 엔티티이고, 엔티티의 필드는 무조건 테이블과 매핑된다고 생각할필요가 없습니다.
자연스럽게 추가적인 필드를 보관하는 엔티티가 있을 수 있고, 테이블과 도메인이 달라도 됩니다.  
여기서 말하는 달라도 된다는 의미는 `@Entity` 도메인이 아니라 엔티티에 관련된 로직을 처리하는 도메인 객체를 말하는 이야깁니다.  
  
## 에러 코드에 대한 생각  
에러 코드는 내부에서 사용할 용도, 클라이언트 계층에서 분리해서 사용자에게 전달해야하는 경우로 나누어 생각해봐야합니다.  
  
에러 코드를 만든다는 것은 클라이언트에서 예외 상황을 반드시 구분해서 사용자에게 전달하는 목적이 아닌 이상 불필요한 코드가 발생한다.  
+ 디버그 용도라고 할지라도 stack trace가 남기 때문에 어디서 예외가 발생햇는지 알수 있다.

![image_126.png](image_125.png)
  
## JPA의 자동화 값을 신뢰해도 되는가  
**JPA Auditing**  
자동으로 수정한 사람, 등록한 정보, 등록된 시간, 수정된 시간을 입력해주는 기능입니다.  
이걸 활용해서 다른 필드에도 이 값을 사용하는건 추천하지 않습니다.  
  
1. 날짜라는건 서버 시간에 따라, 어떤 옵션으로 설정되었는지에 따라 다릅니다.
2. 외부에 노출해야하는 필드는 무조건 직접 작성하는 것이 안전합니다.  
  
## 서비스 로직의 비즈니스 검증 로직  
서비스에서 검증로직을 별도의 클래스나 `private`메서드로 분리해서 간단하게 작성하는 방법을 추천합니다.  
  
## 스케줄러 등장
1. 스케줄러
2. 스프링 배치를 작성하여 Jenkins 스케줄러에 붙여 돌린다.
3. 수정해야하는 테이블이 커진다면 멀티모듈을 사용한다.  
  
정해진 시간에 특정 테이블에 정보를 수정해야하는 경우 스케줄러를 사용합니다. 
이때 너무 많은 데이터를 수정해야하는 경우 추가 서버를 만들어서 스케줄러를 돌리면 
1번 서버 스케줄러 동작, 2번 스케줄러 동작으로 2번에 데이터 업데이트가 발생합니다.  
  
그래서 이걸 방지하기 위해서 별도의 스케줄러 서버를 만들어서 `API`통신을 통해서 스케줄러만 돌리는 서버를 작성할 수 있습니다.  
  
서버를 돌린다는건 백엔드 로직이 실행될 때 서버에 과부하를 분산시키는게 목적인데, 
이 로직을 필드로 추가하여 관리 할 수 있는 상황이라면 (예: 연차 계산로직을 필드로 분리해서 테이블만 업데이트하면 되는 경우)  
차라리 로직을 줄이고 테이블로 관리하는게 유지보수에 편할 수 있다는걸 염두해야합니다.  
  
## 도메인과 엔티티 분리  
![image_128.png](image_128.png)

![image_130.png](image_130.png)  
  
+ 레이어드 아키텍처는 DB에 의존적으로 작성되는 게 단점인결 염두하고 만든 아키텍처이므로 여기에 해당하지 않습니다.
+ 도메인과 엔티티를 분리하는 이유는 DB에 의존적이지 않도록 작성하여 DB 변경시 유연하게 대체할 수 있습니다.  
  
그 방식이 헥사고날 아키텍처 / 클린 아키텍처 구조가 됩니다.  
  
## 프로젝션과 객체지향 쿼리  
```Java
SELECT new Projection(name,age,count) FROM XXXX;
```  
```Java
SELECT t FROM Team as t;
```  
이 방식의 차이는 속도가 프로젝션이 월등히 빠르고 시간을 투자할만한 가치가 있을 경우에 권장합니다.
시간 투자한 만큼 속도가 사용자가 느끼기에 다르지 않다면 차라리 다른 기능을 개발하는 것이 좋습니다.  
  
객체지향적인 코드는 테스트 코드나 유지보수에 간편하므로 잘 생각하고 작성하는 게 좋습니다.  
  
## 캐시도 트레이드 오프다.  
Redis나 아른 캐시 DB를 사용하는 것도 별도의 캐시를 관리해야하기 때문에 
자주 조회하는 정보가 아닌이상 무작정 캐시를 추가하는건 좋은 방식이 아닙니다.  
  
## pathVariable  
RestApi스럽게 코드를 작성할 수 있는 장점이 있습니다.  
다만 모니터링을 통해서 코드를 개선하려고 한다면 집계할 수 없기 때문에 애매합니다.
만약 `api/v1/team/1`,`api/v1/team/2` 처럼 숫자가 끝일 경우에는 큰 상관이 없을 수 있지만  
`api/v1/team/1/member/1` 처럼 중간에 다른 고정값이 들어오면 집계하기가 까다롭습니다.  
  
차라리 확장에도 유리하고 추가적인 검증로직이나 객체지향적으로 설계할 수 있는 `JsonDto`를 사용하는 방법도 있습니다.  
  
## visitor
`MemberRepository.findById()`가 있을 때, 모든 서비스 `AService ~ ZService`까지 모두 `MemberRepository.findById()`를 사용해야한다면 
`.orElseThrow`를 필요한 만큼 반복적으로 작성해야합니다.  
  
처리하는 방식은 다양하지만 이렇게 리포지토리를 다양한 서비스 객체에서 사용한다면 
저 `orElseThrow`만 담당하는 서비스 객체를 사용하여 `MemberRepository.findById`)를  사용하는 모든 서비스 객체가 중간 서비스 객체를 의존하면 됩니다.  


![image_132.png](image_132.png)  

// LocalDate 월말을 가져오고 싶다, 월초를 가져오고 싶다.
// TemperalAdJuster.firstInMonth

절대적인 시간을 위해서 숫자로 저장하는 경우도 있다.

// sealed class + 자바 21 switch patten maching
// Cat,Dog