# 격리수준(Isolation Level)

트랜젹션의 격리수준은 여러 트랜잭션이 동시에 처리될때 특정 트랜잭션이 다른 트랜잭션에서 
변경하거나 조회하는 테이블을 볼 수 있게 허용하는 수준을 결정하는 것입니다.  
  
+ `READ UNCOMMITED`
+ `READ COMMITED`
+ `REPEATABLE READ`
+ `SERIALIZABLE`
  
아래로 내려갈 수 록 공유하는 레코드의 범위가 작아집니다.  
  
격리 수준에 따라 세가지 부정합 문제점이 발생할 수 있습니다.  

| 문제 유형                | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|----------------------|------------------|----------------|-----------------|--------------|
| Dirty Reads          | 발생               | 방지             | 방지              | 방지           |
| Non-Repeatable Reads | 발생               | 발생             | 방지              | 방지           |
| Phantom Reads        | 발생               | 발생             | 발생              | 방지           |

+ Dirty Reads:
  + 문제: 다른 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있음.
  + 예시: A 트랜잭션이 데이터를 수정하는 동안 B 트랜잭션이 아직 수정되지 않은 데이터를 읽을 수 있음.
+ Non-Repeatable Reads:  
  + 문제: 같은 쿼리를 두 번 실행할 때, 결과가 다를 수 있음.
  + 예시: A 트랜잭션이 같은 데이터를 두 번 읽는 동안 B 트랜잭션이 데이터를 수정하여 첫 번째와 두 번째 읽은 값이 다를 수 있음.
+ Phantom Reads:
  + 문제: 한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때, 결과 집합이 달라질 수 있음.
  + 예시: A 트랜잭션이 범위를 조회하는 동안 B 트랜잭션이 데이터를 추가하여 처음에는 없던 데이터가 나타날 수 있음.
  
  
## 언두로그 저장시점
데이터를 저장하는 INSERT도 언두로그에 저장되어 관리됩니다.  

+ 트랜잭션A는 테이블 `book`에 데이터를 저장
+ 트랜잭션B는 테이블 `book`을 조회
  
이때 트랜잭션B가 먼저 트랜잭션을 시작한 상태에서 트랜잭션 A가 데이터를 저장했다면
테이블 `book`의 언두 로그를 언제부터 저장하는지 알아보겟습니다.  
    
### 격리수준 REPEATABLE READ
언두 로그 슬롯이 부족할 경우 트랜잭션을 시작할 수 없는 문제가 발생하기 때문에 
트랜잭션이 오래 지속되어 언두 로그가 누적되는 것을 방지해야합니다.  

전제 조건은 트랜잭션 B가 먼저 `BEGIN;`으로 트랜잭션을 시작한 후
`SELECT * FROM book`를 언제 실행하는지에 따라 언두 로그가 저장되는지 확인합니다.  
  
```SQL
트랜잭션 B: BEGIN;

//---
트랜잭션 A: BEGIN;
트랜잭션 A: insert into book (name) values ('트랜잭션A가 저장후 COMMIT후 트랜잭션 B가 조회');
트랜잭션 A: COMMIT;
//---

트랜잭션 B: SELECT * FROM BOOK;
+----+-----------------------------------------------+-----------+------------+------+
| id | name                                          | publisher | publisher2 | ppap |
+----+-----------------------------------------------+-----------+------------+------+
| 1  | 트랜잭션A가 저장후 COMMIT후 트랜잭션 B가 조회 | NULL      | NULL       | NULL |
+----+-----------------------------------------------+-----------+------------+------+
```    
트랜잭션 B가 먼저 시작 되었지만 , 테이블 `book`를 조회하지 않으면 언두로그가 발생하지 않습니다.  
  
```SQL
트랜잭션 B: BEGIN;
Query OK, 0 rows affected (0.00 sec)

트랜잭션 B: SELECT * FROM BOOK;
+----+-----------------------------------------------+-----------+------------+------+
| id | name                                          | publisher | publisher2 | ppap |
+----+-----------------------------------------------+-----------+------------+------+
| 16 | 트랜잭션A가 저장후 COMMIT후 트랜잭션 B가 조회 | NULL      | NULL       | NULL |
+----+-----------------------------------------------+-----------+------------+------+
1 row in set (0.00 sec)

//---
트랜잭션 A: BEGIN;
트랜잭션 A: insert into book (name) values ('트랜잭션 B가 조회후 데이터 저장');
트랜잭션 A: COMMIT;
//---

트랜잭션 B: SELECT * FROM BOOK;
+----+-----------------------------------------------+-----------+------------+------+
| id | name                                          | publisher | publisher2 | ppap |
+----+-----------------------------------------------+-----------+------------+------+
| 16 | 트랜잭션A가 저장후 COMMIT후 트랜잭션 B가 조회 | NULL      | NULL       | NULL |
+----+-----------------------------------------------+-----------+------------+------+
1 row in set (0.00 sec)
```
반복 읽기가 가능하도록 언두 로그가 저장된 것을 확인할 수 있습니다.  
만약 트랜잭션 B가 데이터를 읽고 트랜잭션이 종료되어있지 않은 상태로 유지가 된다면, 
다른 트랜잭션이 데이터를 삽입하고 저장하는 행동이 반복된다면 언두 로그는 계속 유지가 될 수 있습니다.  
따라서 격리수준이 `READ COMMITED`이상으로 읽는 다면 트랜잭션을 최대한 짧게 유지하는 것이 중요합니다.  
  
### FOR UPDATE
`REPEATABLE READ`에서 `FOR UPDATE`처럼 언두 로그가 아닌 실제 테이블의 락을 조회하는 경우에 
문제가 발생할 수 있습니다.  
  
`FOR UPDATE`는 언두 로그가 아닌 현재 테이블 레코드의 락을 획득하기 때문에 반복읽기가 적용이 안됩니다.ㅎ