# 책 요구사항 05-01,02
  
## 목표
1. 책 생성, 대출 ,반납 API를 온전히 개발하며 지금까지 다루었던 모든 개념을 실습해본다.  
2. 객체지향적으로 설계하기 위한 연관관계를 이해하고, 연관관계를 이해하고, 연관관계의 다양한 옵션에 대해 이해한다.
3. JPA에서 연관관계를 매핑하는 방법을 이해하고, 연관관계를 사용해 개발할 때와 사용하지 않고 개발할 때의 차이점을 이해한다.  
  
## 요구사항  

### 책 등록  
API 명세  
+ HTTP Method: POST
+ HTTP Path: /book  
+ HTTP Body: (JSON)  
```json
{
  "name": String // 책이름
}
```
테스트 코드를 작성하는 이유는 기능에 대한 검증, 유연한 설계를 할 수 있도록 집중의 방향을 
인터페이스로 하기 때문이다.  
  
그러면 단순한 검증보다는 설계에 대해 고민을 하려면 인터페이스에 집중을 해야하기 때문에 
그 방식중에 하나가 `TDD` 라는 방식이고 입니다.  
  
그러면 구조에 대해서 고민을 해야한다.  

외부 요청을 받을 계층은 `Controller`가 단순한 값에 대한 검증을 하고 
책을 등록하다는 기능을 서비스 계층에서 전달합니다.  
  
서비스 계층은 내부적으로 비스니스인 책 이름에 대한 자세한 검증을 합니다. 이때 서비스 검증은 
해당 서비스에 특화된 비즈니스 검증이기 때문에 도메인에서 하는 검증과는 다른 
비즈니스로 보여줄 수 있는 검증과 에러메세지를 가지고 있어야합니다.  
  
도메인은 실제 비즈니스 로직을 실행하는 내부 로직이 포함되어있으며 그 결과를 서비스에게 전달하거나 
내부 상태를 변경합니다.  
  
그 결과를 리포지토리에 저장합니다.  
  
```SQL
create table book
(
    id   bigint auto_increment,
    name varchar(255),
    primary key (id)
);
```  
1. `@Column` 기본 문자열 길이가 255이기 때문에 동일할 경우 `@Column`을 생략할 수 있다.
2. 문자열 필드는 최적화를 해야하는 경우가 아니라면 조금 여유롭게 설정하는 것이 좋다.  
    이유는 미래에는 더 긴 데이터가 들어올 수 있기 때문입니다. 데이터가 많은 상태에서 늘리기는 어렵다.
  
`ORM`를 통해서 `Hibernate` 사용할 때는 테이블을 기준으로 엔티티를 생성해야합니다.  
  
위 조건으로 엔티티를 생성합니다.  
  
**JPA 객체를 새로 만들면 , 객체를 저장하는 Repository도 같이 만듭니다.**  
  
**DTO는 API스펙에 따라 만드는게 달라진다.**  
결국은 객체라는건 사용하는 계층이 어딘지에 따라서 계층에 필요한 기능을 가지고 있으면 좋다.  
  
### 대출 기능
사용자가 책을 빌릴수 있다.  
다른 사람이 그 책을 먼저 빌렸다면 빌릴 수 없다.  
    
**강사님과 차이점**  
테이블의 구조를 만들 때, 책이라는 테이블에 빌린 사람의 정보를 입력하려고 했다.  
```Java
//저장된 책 엔티티를 조회후 상태를 수정하려고 했습니다.
Book book = repository.findByName("클린 코드");
book.loanToUser("빌린 사람이름"):
```  
이런식으로 하려고 했는데 사실 생각해보면, 유저나 책에 빌린 정보를 기입하는건 물론 불필요한 조인을 줄일 수 있겠지만, 
관련된 일이 있을 때마다 책과 유저에 추가되면 관리가 어렵고 누구에게 정보를 입력할지 어렵다.  
  
따라서 유저의 대출 기록을 저장하는 테이블을 강사님은 만들려고 하신것.  
이걸 테스트 코드로 작성할때 테이블 구조에 대해서 생각을 해보면,  
  
**1안.**   
TDD 관점과 테스트 코드로 볼때 행동에 대해서 테스트를 하려고 한다.  
책 대출 기능에는 책 빌리는 것, 없을 경우에는 못빌린다는 메세지를 전달해야한다.  
  

```Java
@Entity
public class UserLoanHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private long userId;
    private String bookName;

    private boolean isReturn;
    
}
```
이렇게 설정할 경우 `true = 1`, `false = 0`으로 잘 매핑됩니다.  
  
  
## 반납 기능  
반납은 대출과 동일한 테이블을 사용합니다.  
강사님이 말씀하신 내용을 정리하면 "테이블의 필드는 사용자의 어떤 정보를 영구적으로 저장할 것인지 생각하고 추가해야합니다."  
  
반납 기능은 반납하는 사용자의 이름과 반납하는 책의 이름, 해당 책이 반납이 되었는지 확인하기 
  
지금은 대출 API와 반납 API가 동일한 `Body`를 가지고 있습니다.  
  
이때는 새로운 DTO를 만드는게 좋습니다.  
여기에 제 생각도 동일한 이유는  
현재 어느 회사의 DTO는 수정,입력,조회를 모두 같은 DTO를 사용하고 있습니다.  
그러다보니 데이터가 넘어와도 어떤게 필요한 데이터인지, 데이터가 없는건지 확인하려면 `Mybatis xml`과 `dto`까지 확인해야합니다.  
  
나중에 수정이나 입력에 필요한 정보가 이후에 추가될때 모든 다른 기능에도 불필요한 필드가 생기게 되고, 
중복되는 테이블 컬럼명이 발생하면 그때부터는 구분하기 위해서 xml도 수정해야하고, 직렬화 이름을 변경하는 작업도 발생합니다.  
  
그래서 강사님과 생각이 동일한데, 새로 DTO를 만들어서 지금은 같다고 하더라도 이후에 명세가 변경될 경우 
불필요한 코드 수정이 발생하지 않게 `side-effect`를 줄일 수 있습니다.  
  
### 포인트  
```JSON
{
  "user_name": "jack",
  "book_name": "clean code"
}
```  
현재 책 대출 정보 테이블 DDL
```SQL
create table user_loan_history
(
    id        int auto_increment        primary key,
    user_id   bigint       null,
    book_name varchar(255) null,
    is_return tinyint(1)   null
);
```  
**내가 작성한 서비스 로직**  
1. 넘어온 유저정보가 일치하는지 확인을 한다.
2. 유저 정보가 있을 경우 id와 책 이름으로 대출된 기록이 있는지 조회한다.
3. 조회 기록이 있을 경우 반납으로 변경한다.  
  
이렇게 단순히 접근을 했는데, 강사님은 다른 방향입니다.  
1. 대출 기록 테이블을 조회하기 위해서는 user의 id와 book의 name을 알아야한다.  
2. 그래서 user 정보와 책 정보를 확인하는 로직을 추가합니다.  
  
먼저 알아야하는 것은 요청 정보에 없는 user의 id를 알아야합니다.  
  
### SQL 대신 ORM을 사용하는 이유  
SQL 대신 ORM을 사용하게 된 이유중 하나가 `DB 테이블과 객체는 패러다임이 다르기 때문이다.`  
마찬가지고 클래스가 의존성까지 생성하는 책임과 분리를 통해서 하나의 클래스를 수정해도 
다른 클래스에도 영향이 가지 않도록 작성합니다.  
  
JPA나 스프링 부트나 모두 객체지향적인 코드를 작성하기 위해도와줍니다.  
  
### 작성된 코드를 더 객체지향으로 만드는 방법
  
지금은 사용자, 책 정보, 책 대출 기록에 대한 리포지토리가 모두 분리되어있습니다.  
사용자가 책을 빌기는 행위를 하기 때문에 사용자와 책 대출 기록은 밀접한 관계가 있습니다.  
  
현재 코드를 밀접한 관계를 코드로 표시해서 객체지향적으로 작성하도록 합니다.